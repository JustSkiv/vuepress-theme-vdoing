---
title: String
date: 2022-09-13
permalink: /pages/string/
categories:
  - Основы языка
  - Типы данных
tags:
  - типы данных
author: Николай Тузов
---


Строки - это неизменяемая последовательность байтов.

Встроенная функция `len(str)` возвращает количество байтов в строке. Важный момент - именно байтов, а не символов (символ представлен несколькими байтами).
Один символ = 32/8 байтам. Потому что символ это руна `int32` а байт это `uint8`

<!-- more -->

## Операции со строками

Получения i-го байта строки - операция str[i]. Опять же, i-й байт не всегда будет эквивалентен i-му символу.

```go
str := "some text"
fmt.Println(len(str)) // 9
fmt.Println(str[1])   // 111
```

Получения подстроки str - str[from:to]. Возвращается новая строка, состоящая из байтов исходной - от начиная с from, заканчивая to (не включительно).

Оба операнда можно опустить: str[from:], str[:to]. Тогда будут использованы дефолтные значения - 0 и len(str)

Если индексы выходят за пределы len(str), получим панику.

Конкатенация строк: оператор +. Будет создана новая строка.

Сравнение строк: ==, > и т.п. (лексикографическое сравнение - что это?)

Изменять значение строк нельзя. К примеру, мы не можем сделать так:

```go
str := "text"
str[0] = 'a' // cannot assign to t[0] (strings are immutable)
```

Можно лишь присвоить переменной значение новой строки:

```go
str := "text"
str = "another text"
```

В некоторых случаях может сложиться впечатление, что значение строки всё же меняется, например:

```go
str := "some"
str2 := str
str += " text"
fmt.Println(str) // "some text"
```

Строка str не изменяется - создаётся новая и присваивается этой переменной. Значение str2 не изменится.

Что даёт неизменность строк - дёшево копировать строки и получать подстроки, т.к. не выделяется новая память.

Рассказать про отличиая "text", `text`, 'char'.